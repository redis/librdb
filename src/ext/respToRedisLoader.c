#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <fcntl.h>
#include "extCommon.h"
#include "readerResp.h"

#ifdef USE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

/* MSG_NOSIGNAL is Linux-specific. On other platforms, we use 0 and handle SIGPIPE differently */
#ifndef MSG_NOSIGNAL
#define MSG_NOSIGNAL 0
#endif

#define PIPELINE_DEPTH_DEF          200   /* Default Number of pending cmds before waiting for response(s) */
#define PIPELINE_DEPTH_MAX          1000  /* limit the max value allowed to configure for pipeline depth */

#define NUM_RECORDED_CMDS           400   /* Number of commands to backlog, in a cyclic array */
#define RECORDED_KEY_MAX_LEN        40    /* Maximum payload size from any command to record into cyclic array */

#define REPLY_BUFF_SIZE             1024  /* reply buffer size */

#define MAX_EINTR_RETRY             5
#define RECV_CMD_TIMEOUT_SEC        10    /* recv() command timeout in seconds */

struct RdbxRespToRedisLoader {

    struct {
        int num;
        int pipelineDepth;
        /* pointers to (static) strings that hold the template of the command sent (no char* allocation required) */
        const char *cmd[NUM_RECORDED_CMDS];
        /* strncpy() of the key sent */
        char key[NUM_RECORDED_CMDS][RECORDED_KEY_MAX_LEN];
        /* if restore cmd, then serialized size. Otherwise, set to 0 */
        size_t restoreSize[NUM_RECORDED_CMDS];
    } pendingCmds;

    RespReaderCtx respReader;
    RdbParser *p;
    int fd;
    int fdOwner; /* Set to 1 if this entity created the socket, and it is the one to release. */
    int origSocketFlags;
#ifdef USE_OPENSSL
    SSL *ssl;           /* OpenSSL connection object (NULL if plain TCP) */
    SSL_CTX *ssl_ctx;   /* OpenSSL context (NULL if plain TCP) */
#endif
};

/* cb to report RESP error. Returns 1 to propagate. 0 to mask. */
static int onReadRepliesErrorCb(void *context, char *msg) {
    RdbxRespToRedisLoader *ctx = context;

    int currIdx = ctx->respReader.countReplies % NUM_RECORDED_CMDS;

    /*
     * librdb should not fail trying to load empty module
     *
     * If RDB2RESP was configured to "supportRestoreModuleAux" and generates
     * RESTOREMODAUX commands (currently Redis enterprise only), then if RDB was
     * generated by a server with some module, but user didn't make any use of that
     * module, attempting to play it to another server that wasn't loaded with that
     * module, the RDB parser will fail. This is because the module always store
     * something in the AUX field, and the RDB parser will try to load it.
     *
     * In order to overcome this issue, A module that its AUX payload is less than
     * 15 Bytes (including RDB version and checksum) counted as AUX field of an empty
     * Module (not in use), then the parser, when restoring the empty module, it
     * should ignore returned error: "-ERR Module X not found..."
     */
    if ((strcmp(ctx->pendingCmds.cmd[currIdx], "RESTOREMODAUX")==0) &&
        (ctx->pendingCmds.restoreSize[currIdx] < 15) &&
        (strncmp(msg, "ERR Module", 10) == 0) && /* error starts with "-ERR Module" */
        (strstr(msg, "not found")))              /* error includes "not found" */
        return 0; /* mask error */

    char buf[9];
    RDB_reportError(ctx->p, (RdbRes) RDBX_ERR_RESP_WRITE,
                    "\nerror from dst '-%s' on key '%s' on command '%s' (RESP Command #%zu)\n",
                    msg,
                    __RDB_key(ctx->p, ctx->pendingCmds.key[currIdx], buf),
                    ctx->pendingCmds.cmd[currIdx],
                    ctx->respReader.countReplies);

    return 1; /* propagate error */
}

/* Read 'numToRead' replies from the socket.
 *
 * numToRead - minimum number of replies to read from the socket before
 *                    returning.
 * sentError -        if set, an error occurred while writing to the server. In
 *                    this case the function will try to read replies from the
 *                    server. Maybe one of the replies will contain an error message
 *                    that explains why write got failed. Whether error message is
 *                    received or not, the function will return to the original issue.
 *
 * Return 0 for success, 1 otherwise. */
static int readReplies(RdbxRespToRedisLoader *ctx, int numToRead, int sentError) {
    int retries = 0;
    char buff[REPLY_BUFF_SIZE];

    RespReaderCtx *respReader = &ctx->respReader;
    size_t countRepliesBefore = respReader->countReplies;
    size_t repliesExpected = respReader->countReplies + numToRead;

    while ((respReader->countReplies < repliesExpected) || (sentError)) {
        int bytesReceived;

#ifdef USE_OPENSSL
        if (ctx->ssl) {
            bytesReceived = SSL_read(ctx->ssl, buff, sizeof(buff));
            if (bytesReceived <= 0) {
                int ssl_err = SSL_get_error(ctx->ssl, bytesReceived);
                if (ssl_err == SSL_ERROR_WANT_READ || ssl_err == SSL_ERROR_WANT_WRITE) {
                    errno = EAGAIN;
                    bytesReceived = -1;
                } else if (ssl_err == SSL_ERROR_ZERO_RETURN) {
                    bytesReceived = 0;  /* Clean shutdown */
                } else {
                    errno = EIO;
                    bytesReceived = -1;
                }
            }
        } else
#endif
        {
            bytesReceived = recv(ctx->fd, buff, sizeof(buff), 0);
        }

        if (bytesReceived > 0) {
            /* Data was received, process it */
            if (unlikely(RESP_REPLY_ERR == readRespReplies(respReader, buff, bytesReceived))) {
                return 1;
            }
            continue;
        }

        /* handle error */

        if (sentError)
            return 0; /* Done lookup for error message. Return to original issue */

        if (bytesReceived == 0) {
            RDB_reportError(ctx->p, (RdbRes) RDBX_ERR_RESP2REDIS_CONN_CLOSE,
                            "Connection closed by the remote side");
            return 1;
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                retries++;
                RDB_log(ctx->p, RDB_LOG_INF, 
                        "No reply from redis-server for %d seconds", 
                        retries * RECV_CMD_TIMEOUT_SEC);
                
                /* Parser got external error? Currently Used only for testing */
                if (RDB_getErrorCode(ctx->p) != RDB_OK)
                    return 1;
                
                continue;
            }

            RDB_reportError(ctx->p,
                            (RdbRes) RDBX_ERR_RESP2REDIS_FAILED_READ,
                            "Failed to recv() from Redis server. errno=%d: %s",
                            errno, strerror(errno));
            return 1;
        }
    }

    ctx->pendingCmds.num -= (respReader->countReplies - countRepliesBefore);
    return 0;
}

/* For debugging, record the command into the cyclic array before sending it */
static inline void recordCommandSent(RdbxRespToRedisLoader *ctx,RdbxRespWriterStartCmd *cmd) {
    int recordCmdEntry = (ctx->respReader.countReplies + ctx->pendingCmds.num) % NUM_RECORDED_CMDS;

    /* no need to copy the cmd. handlersToResp took care to pass a string that is persistent and constant */
    ctx->pendingCmds.cmd[recordCmdEntry] = cmd->cmd;
    strncpy(ctx->pendingCmds.key[recordCmdEntry], cmd->key, RECORDED_KEY_MAX_LEN-1);
    ctx->pendingCmds.key[recordCmdEntry][RECORDED_KEY_MAX_LEN-1] = '\0';
    ctx->pendingCmds.restoreSize[recordCmdEntry] = cmd->restoreSize;
}

#ifdef USE_OPENSSL
/* SSL doesn't support writev, so we need to send each iovec separately */
static ssize_t writevSSL(SSL *ssl, struct iovec *iov, int iovCnt) {
    ssize_t totalWritten = 0;
    // TODO: aggregate small iov entries into one SSL_write()
    for (int i = 0; i < iovCnt; i++) {
        int sent = SSL_write(ssl, iov[i].iov_base, iov[i].iov_len);
        if (sent <= 0) {
            int ssl_err = SSL_get_error(ssl, sent);
            if (ssl_err == SSL_ERROR_WANT_WRITE || ssl_err == SSL_ERROR_WANT_READ) {
                errno = EAGAIN;
            } else {
                errno = EIO;
            }
            return -1;
        }
        totalWritten += sent;
    }

    return totalWritten;
}
#endif

/* Write the vector of data to the socket with writev() sys-call.
 * Return 0 for success, 1 otherwise. */
static int redisLoaderWritev(void *context, struct iovec *iov, int iovCnt,
                             RdbxRespWriterStartCmd *startCmd, int endCmd)
{
    ssize_t writeResult;
    int retries = 0;

    RdbxRespToRedisLoader *ctx = context;

    if (unlikely(ctx->pendingCmds.num == ctx->pendingCmds.pipelineDepth)) {
        if (readReplies(ctx, 1 /* at least one */, 0))
            return 1;
    }

    if (startCmd) recordCommandSent(ctx, startCmd);

    while (1)
    {
#ifdef USE_OPENSSL
        if (ctx->ssl) {
            writeResult = writevSSL(ctx->ssl, iov, iovCnt);
        } else
#endif
        {
            struct msghdr msg = { .msg_iov = iov, .msg_iovlen = iovCnt };
            writeResult = sendmsg(ctx->fd, &msg, MSG_NOSIGNAL /*Ignore SIGPIPE signal*/);
        }

        /* check for error */
        if (unlikely(writeResult == -1)) {
            if (errno == EINTR) {
                if ((retries++) >= MAX_EINTR_RETRY) {
                    RDB_reportError(ctx->p, (RdbRes) RDBX_ERR_RESP2REDIS_FAILED_WRITE,
                                    "Failed to write socket. Exceeded EINTR retry limit");
                    break;
                }
                continue;
            } else {
                RDB_reportError(ctx->p, (RdbRes) RDBX_ERR_RESP2REDIS_FAILED_WRITE,
                                "Failed to write socket (errno=%d)", errno);
                break;
            }
        }

        /* crunch iov entries that were transmitted entirely */
        while ((iovCnt) && (iov->iov_len <= (size_t) writeResult)) {
            writeResult -= iov->iov_len;
            ++iov;
            --iovCnt;
        }

        /* if managed to send all iov entries */
        if (likely(iovCnt == 0)) {
            ctx->pendingCmds.num += endCmd;
            return 0;
        }

        /* Update pointed iov entry. Only partial of its data sent */
        iov->iov_len -= writeResult;
        iov->iov_base = (char *) iov->iov_base + writeResult;
    }

    /* Error occurred. Try to receive error msg from dst, which might explain
       why write got failed */
    readReplies(ctx, 0, 1/*sentError*/);
    return 1;
}

/* Flush the pending commands by reading the remaining replies.
 * Return 0 for success, 1 otherwise. */
static int redisLoaderFlush(void *context) {
    RdbxRespToRedisLoader *ctx = context;
    if (ctx->pendingCmds.num)
        return readReplies(ctx, ctx->pendingCmds.num, 0);
    return 0;
}

/* Delete the context and perform cleanup. */
static void redisLoaderDestroy(void *context) {
    struct RdbxRespToRedisLoader *ctx = context;

    /* not required to flush on termination */

#ifdef USE_OPENSSL
    /* Clean up SSL if used */
    if (ctx->ssl) {
        SSL_shutdown(ctx->ssl);
        SSL_free(ctx->ssl);
    }
    if (ctx->ssl_ctx) {
        SSL_CTX_free(ctx->ssl_ctx);
    }
#endif

    shutdown(ctx->fd, SHUT_WR); /* graceful shutdown */

    /* Restore the original socket flags */
    if (fcntl(ctx->fd, F_SETFL, ctx->origSocketFlags) == -1) {
        RDB_reportError(ctx->p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to restore original socket flags. errno=%d: %s",
                        errno, strerror(errno));
    }

    if (ctx->fdOwner) close(ctx->fd);

    RDB_free(ctx->p, ctx);
}

static RdbRes redisAuthCustomized(RdbxRespToRedisLoader *ctx, RdbxRedisAuth *auth) {
    int i, iovs;
    RdbRes res = RDB_OK;

    /* custom auth command - Need to break it into tokens based on spaces and
    * tabs. And then translate it into RESP protocol */

    char prefix[32];

    RdbxRespWriterStartCmd startCmd = {"<AUTH_CUSTOMIZED_CMD>", "", 0};

    /* allocate iovec (2 for header and trailer. 3 for each argument) */
    struct iovec *iov = (struct iovec *)malloc((auth->cmd.argc * 3 + 2) * sizeof(struct iovec));
    /* allocate temporary buffer to assist converting length to string of all args */
    char (*lenStr)[21] = (char (*)[21])malloc(auth->cmd.argc * 21 * sizeof(char));

    if (iov == NULL || lenStr == NULL) {
        RDB_reportError(ctx->p, RDB_ERR_FAIL_ALLOC,
                        "Failed to allocate for customized AUTH (tokens=%d)", auth->cmd.argc);
        res = RDB_ERR_FAIL_ALLOC; // Return an error code
        goto AuthEnd;
    }

    /* set number of elements in the prefix of the RESP command */
    iov[0].iov_len = snprintf(prefix, sizeof(prefix)-1, "*%d", auth->cmd.argc);
    iov[0].iov_base = prefix;

    for ( i = 0, iovs = 1 ; i < auth->cmd.argc ; ++i)
    {
        size_t tLen = strlen(auth->cmd.argv[i]);
        IOV_CONST(&iov[iovs++], "\r\n$");
        IOV_VALUE(&iov[iovs++], tLen, lenStr[i]);
        IOV_STRING(&iov[iovs++], auth->cmd.argv[i], tLen);
    }
    IOV_CONST(&iov[iovs++], "\r\n");
    redisLoaderWritev(ctx, iov, iovs, &startCmd, 1);

AuthEnd:
    if (iov) free(iov);
    if (lenStr) free(lenStr);
    return res;
}

static RdbRes redisAuth(RdbxRespToRedisLoader *ctx, RdbxRedisAuth *auth) {
    int iovs;
    char userLenStr[21], pwdLenStr[21];

    if ((auth->pwd == NULL) && (auth->cmd.argc == 0))
        return RDB_OK;

    /* if customized auth command */
    if (auth->cmd.argv)
        return redisAuthCustomized(ctx, auth);

    /* AUTH [username] password */

    RdbxRespWriterStartCmd startCmd = {"AUTH", "", 0};

    struct iovec iov[10];
    if (auth->user) {
        IOV_CONST(&iov[0], "*3\r\n$4\r\nauth\r\n$");
        /* write user */
        IOV_VALUE(&iov[1], strlen(auth->user), userLenStr);
        IOV_STRING(&iov[2], auth->user, strlen(auth->user));
        IOV_CONST(&iov[3], "\r\n$");
        /* write pwd */
        IOV_VALUE(&iov[4], strlen(auth->pwd), pwdLenStr);
        IOV_STRING(&iov[5], auth->pwd, strlen(auth->pwd));
        IOV_CONST(&iov[6], "\r\n");
        iovs = 7;
    } else {
        IOV_CONST(&iov[0], "*2\r\n$4\r\nauth\r\n$");
        /* write pwd */
        IOV_VALUE(&iov[1], strlen(auth->pwd), pwdLenStr);
        IOV_STRING(&iov[2], auth->pwd, strlen(auth->pwd));
        IOV_CONST(&iov[3], "\r\n");
        iovs = 4;
    }

    redisLoaderWritev(ctx, iov, iovs, &startCmd, 1);
    return RDB_OK;
}

/*** LIB API functions ***/

_LIBRDB_API void RDBX_setPipelineDepth(RdbxRespToRedisLoader *r2r, int depth) {
    r2r->pendingCmds.pipelineDepth = (depth <= 0 || depth>PIPELINE_DEPTH_MAX) ? PIPELINE_DEPTH_DEF : depth;
}

/* Create a loader from an existing file descriptor */
_LIBRDB_API RdbxRespToRedisLoader *RDBX_createRespToRedisFd(RdbParser *p,
                                                            RdbxToResp *rdbToResp,
                                                            RdbxRedisAuth *auth,
                                                            int fd) {
    /* Save the original socket flags */
    int origSockFlags = fcntl(fd, F_GETFL, 0);
    if (origSockFlags == -1) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to get original socket flags. errno=%d: %s", errno, strerror(errno));
        return NULL;
    }
    
    /* Ensure the socket is in blocking mode */
    if (fcntl(fd, F_SETFL, origSockFlags & ~O_NONBLOCK) == -1) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to configure for blocking mode. errno=%d: %s",
                        errno, strerror(errno));
        return NULL;
    }

    /* Set receive timeout (blocking, but with a limit) */
    struct timeval timeout = { .tv_sec = RECV_CMD_TIMEOUT_SEC, .tv_usec = 0 };
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_SET_TIMEOUT,
                        "Failed to configure timeout for socket. errno=%d: %s",
                        errno, strerror(errno));
        fcntl(fd, F_SETFL, origSockFlags);
        return NULL;
    }

    RdbxRespToRedisLoader *ctx = RDB_alloc(p, sizeof(RdbxRespToRedisLoader));
    if (!ctx) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP_FAILED_ALLOC, "Failed to allocate struct RdbxRespToRedisLoader");
        fcntl(fd, F_SETFL, origSockFlags);
        return NULL;
    }

    memset(ctx, 0, sizeof(RdbxRespToRedisLoader));
    ctx->p = p;
    ctx->fd = fd;
    ctx->origSocketFlags = origSockFlags;
    ctx->fdOwner = 0;
    ctx->pendingCmds.num = 0;
    ctx->pendingCmds.pipelineDepth = PIPELINE_DEPTH_DEF;
    readRespInit(&ctx->respReader);
    setErrorCb(&ctx->respReader, ctx, onReadRepliesErrorCb);

    if (auth && (redisAuth(ctx, auth) != RDB_OK)) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_AUTH_FAILED, "Redis authentication failed.");
        RDB_free(p, ctx);
        fcntl(fd, F_SETFL, origSockFlags);
        return NULL;
    }

    /* Set writer to rdbToResp */
    RdbxRespWriter inst = {ctx, redisLoaderDestroy, redisLoaderWritev, redisLoaderFlush};
    RDBX_attachRespWriter(rdbToResp, &inst);
    return ctx;
}
/* Helper: Create and connect TCP socket to hostname:port */
static int createTcpConnection(RdbParser *p, const char *hostname, int port) {
    struct addrinfo hints, *result, *rp;
    char port_str[6];
    int sockfd = -1;

    /* Convert port to string for getaddrinfo */
    snprintf(port_str, sizeof(port_str), "%d", port);

    /* Setup hints for getaddrinfo */
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;      /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_STREAM;  /* TCP socket */
    hints.ai_flags = 0;
    hints.ai_protocol = 0;

    /* Resolve hostname (supports both IP addresses and FQDNs) */
    int gai_err = getaddrinfo(hostname, port_str, &hints, &result);
    if (gai_err != 0) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_FAILED_CONNECT,
                        "Failed to resolve hostname %s: %s",
                        hostname, gai_strerror(gai_err));
        return -1;
    }

    /* Try each address until we successfully connect */
    int last_errno = 0;
    for (rp = result; rp != NULL; rp = rp->ai_next) {
        sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sockfd == -1)
            continue;

        if (connect(sockfd, rp->ai_addr, rp->ai_addrlen) == 0)
            break;  /* Success */

        last_errno = errno;  /* Save errno from last attempt before close() clobbers it */
        close(sockfd);
        sockfd = -1;
    }

    freeaddrinfo(result);

    if (sockfd == -1) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_FAILED_CONNECT,
                        "Failed to connect to %s:%d (last attempt errno: %s)",
                        hostname, port, strerror(last_errno));
        return -1;
    }

    return sockfd;
}

/* Helper: Configure socket options (blocking mode, timeout) */
static int configureSocket(RdbParser *p, int sockfd, int *origSockFlags) {
    /* Save original socket flags */
    *origSockFlags = fcntl(sockfd, F_GETFL, 0);
    if (*origSockFlags == -1) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to get socket flags. errno=%d: %s", errno, strerror(errno));
        return -1;
    }

    /* Ensure socket is in blocking mode */
    if (fcntl(sockfd, F_SETFL, *origSockFlags & ~O_NONBLOCK) == -1) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to set blocking mode. errno=%d: %s", errno, strerror(errno));
        return -1;
    }

    /* Set receive timeout */
    struct timeval timeout = { .tv_sec = RECV_CMD_TIMEOUT_SEC, .tv_usec = 0 };
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_SET_TIMEOUT,
                        "Failed to set socket timeout. errno=%d: %s", errno, strerror(errno));
        return -1;
    }

#ifdef SO_NOSIGPIPE
    /* On macOS/BSD, use SO_NOSIGPIPE to prevent SIGPIPE on socket writes */
    int set = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(set)) < 0) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_CONF_SOCKET,
                        "Failed to set SO_NOSIGPIPE. errno=%d: %s", errno, strerror(errno));
        return -1;
    }
#endif

    return 0;
}

/* Helper: Initialize loader context structure */
static void initLoaderContext(RdbxRespToRedisLoader *ctx, RdbParser *p, int sockfd, int origSockFlags) {
    memset(ctx, 0, sizeof(RdbxRespToRedisLoader));
    ctx->p = p;
    ctx->fd = sockfd;
    ctx->origSocketFlags = origSockFlags;
    ctx->fdOwner = 1;
    ctx->pendingCmds.num = 0;
    ctx->pendingCmds.pipelineDepth = PIPELINE_DEPTH_DEF;
    readRespInit(&ctx->respReader);
    setErrorCb(&ctx->respReader, ctx, onReadRepliesErrorCb);
}

#ifdef USE_OPENSSL
/* Helper: Create and configure SSL context from config */
static int createSslContext(RdbParser *p, RdbxRespToRedisLoader *ctx, RdbxSSLConfig *sslConfig) {
    /* Initialize OpenSSL library */
    SSL_library_init();
    SSL_load_error_strings();
    OpenSSL_add_all_algorithms();

    /* Create SSL context */
    ctx->ssl_ctx = SSL_CTX_new(TLS_client_method());
    if (!ctx->ssl_ctx) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_CTX_CREATE_FAILED,
                        "Failed to create SSL context");
        return -1;
    }

    /* Load CA certificate for server verification */
    if (sslConfig->cacert_filename || sslConfig->capath) {
        if (!SSL_CTX_load_verify_locations(ctx->ssl_ctx,
                                            sslConfig->cacert_filename,
                                            sslConfig->capath)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_CA_LOAD_FAILED,
                            "Failed to load CA certificate: %s",
                            ERR_error_string(ERR_get_error(), NULL));
            return -1;
        }
    }

    /* Load client certificate (for mutual TLS) */
    if (sslConfig->cert_filename) {
        if (!SSL_CTX_use_certificate_file(ctx->ssl_ctx,
                                           sslConfig->cert_filename,
                                           SSL_FILETYPE_PEM)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_CERT_LOAD_FAILED,
                            "Failed to load client certificate: %s",
                            ERR_error_string(ERR_get_error(), NULL));
            return -1;
        }
    }

    /* Load private key (for mutual TLS) */
    if (sslConfig->private_key_filename) {
        if (!SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx,
                                          sslConfig->private_key_filename,
                                          SSL_FILETYPE_PEM))
        {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_KEY_LOAD_FAILED,
                            "Failed to load private key: %s",
                            ERR_error_string(ERR_get_error(), NULL));
            return -1;
        }

        /* Verify private key matches certificate */
        if (!SSL_CTX_check_private_key(ctx->ssl_ctx)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_KEY_LOAD_FAILED,
                            "Private key does not match certificate");
            return -1;
        }
    }

    /* Set cipher list (TLSv1.2 and below) */
    if (sslConfig->ciphers) {
        if (!SSL_CTX_set_cipher_list(ctx->ssl_ctx, sslConfig->ciphers)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_INIT_FAILED,
                            "Failed to set cipher list: %s",
                            ERR_error_string(ERR_get_error(), NULL));
            return -1;
        }
    }

#ifdef TLS1_3_VERSION
    /* Set ciphersuites (TLSv1.3) */
    if (sslConfig->ciphersuites) {
        if (!SSL_CTX_set_ciphersuites(ctx->ssl_ctx, sslConfig->ciphersuites)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_INIT_FAILED,
                            "Failed to set TLSv1.3 ciphersuites: %s",
                            ERR_error_string(ERR_get_error(), NULL));
            return -1;
        }
    }
#endif

    /* Set verification mode */
    int verify_mode = (sslConfig->verify_mode == RDBX_SSL_VERIFY_PEER)
                      ? SSL_VERIFY_PEER
                      : SSL_VERIFY_NONE;
    SSL_CTX_set_verify(ctx->ssl_ctx, verify_mode, NULL);

    return 0;
}

/* Helper: Perform SSL handshake and verify certificate */
static int performSslHandshake(RdbParser *p, RdbxRespToRedisLoader *ctx,
                               RdbxSSLConfig *sslConfig, int sockfd)
{
    /* Create SSL object */
    ctx->ssl = SSL_new(ctx->ssl_ctx);
    if (!ctx->ssl) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_CTX_CREATE_FAILED,
                        "Failed to create SSL object");
        return -1;
    }

    /* Set SNI (Server Name Indication) */
    if (sslConfig->server_name) {
        if (!SSL_set_tlsext_host_name(ctx->ssl, sslConfig->server_name)) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_HANDSHAKE_FAILED,
                            "Failed to set SNI");
            return -1;
        }
    }

    /* Attach SSL to socket */
    if (!SSL_set_fd(ctx->ssl, sockfd)) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_HANDSHAKE_FAILED,
                        "Failed to attach SSL to socket");
        return -1;
    }

    /* Perform SSL handshake */
    if (SSL_connect(ctx->ssl) <= 0) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_HANDSHAKE_FAILED,
                        "SSL handshake failed: %s",
                        ERR_error_string(ERR_get_error(), NULL));
        return -1;
    }

    /* Verify certificate if required */
    if (sslConfig->verify_mode == RDBX_SSL_VERIFY_PEER) {
        long verify_result = SSL_get_verify_result(ctx->ssl);
        if (verify_result != X509_V_OK) {
            RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_HANDSHAKE_FAILED,
                            "Certificate verification failed: %s",
                            X509_verify_cert_error_string(verify_result));
            return -1;
        }
    }

    return 0;
}

/* Helper: Cleanup SSL resources */
static void cleanupSsl(RdbxRespToRedisLoader *ctx) {
    if (ctx->ssl) {
        SSL_free(ctx->ssl);
        ctx->ssl = NULL;
    }
    if (ctx->ssl_ctx) {
        SSL_CTX_free(ctx->ssl_ctx);
        ctx->ssl_ctx = NULL;
    }
}
#endif /* USE_OPENSSL */

/* Create a loader and establish a TCP connection */
_LIBRDB_API RdbxRespToRedisLoader *RDBX_createRespToRedisTcp(RdbParser *p,
                                                             RdbxToResp *rdbToResp,
                                                             RdbxRedisAuth *auth,
                                                             const char *hostname,
                                                             int port,
                                                             RdbxSSLConfig *sslConfig) {
    int sockfd = -1;
    int origSockFlags = 0;
    RdbxRespToRedisLoader *ctx = NULL;

    /* Step 1: Create TCP connection */
    sockfd = createTcpConnection(p, hostname, port);
    if (sockfd == -1)
        return NULL;

    /* Step 2: Configure socket options */
    if (configureSocket(p, sockfd, &origSockFlags) != 0) {
        close(sockfd);
        return NULL;
    }

    /* Step 3: Allocate and initialize loader context */
    ctx = RDB_alloc(p, sizeof(RdbxRespToRedisLoader));
    if (!ctx) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP_FAILED_ALLOC,
                        "Failed to allocate struct RdbxRespToRedisLoader");
        close(sockfd);
        return NULL;
    }

    initLoaderContext(ctx, p, sockfd, origSockFlags);

#ifdef USE_OPENSSL
    /* Step 4: Setup SSL/TLS if requested */
    if (sslConfig != NULL) {
        if (createSslContext(p, ctx, sslConfig) != 0)
            goto error_cleanup;

        if (performSslHandshake(p, ctx, sslConfig, sockfd) != 0)
            goto error_cleanup;
    }
#else
    /* SSL not compiled in */
    if (sslConfig != NULL) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_SSL_INIT_FAILED,
                        "SSL/TLS support not compiled in. Rebuild with BUILD_TLS=yes");
        goto error_cleanup;
    }
#endif

    /* Step 5: Authenticate if needed */
    if (auth && (redisAuth(ctx, auth) != RDB_OK)) {
        RDB_reportError(p, (RdbRes) RDBX_ERR_RESP2REDIS_AUTH_FAILED,
                        "Redis authentication failed.");
        goto error_cleanup;
    }

    /* Step 6: Attach writer and return */
    RdbxRespWriter inst = {ctx, redisLoaderDestroy, redisLoaderWritev, redisLoaderFlush};
    RDBX_attachRespWriter(rdbToResp, &inst);
    return ctx;

error_cleanup:
#ifdef USE_OPENSSL
    cleanupSsl(ctx);
#endif
    RDB_free(p, ctx);
    close(sockfd);
    return NULL;
}
